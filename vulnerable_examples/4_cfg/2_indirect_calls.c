#include <stdio.h>
#include <string.h>
#include <windows.h>

// so vsc doesn't spit out gcc errors
#ifndef _MSC_VER
#define __try
#define __except(expr) if(0)
#endif


// full parameters size both in 32 and 64 bits
typedef intptr_t myMathInt;

void * stdcallToCdecl4(void *(__stdcall *func)(void*,void*,void*,void*), void * a, void * b, void * c, void * d) {
	return (*func)(a, b, c, d);
}

// this prevents printFlag from being a valid target for an indirect call
__declspec(guard(suppress))
myMathInt printFlag(void) {
	puts("flag{D0n7_u53_uN54f3_5h0R7cU75}");
	return 1337;
}

myMathInt add(myMathInt a, myMathInt b) {
	return a + b;
}

myMathInt sub(myMathInt a, myMathInt b) {
	return a - b;
}

myMathInt mul(myMathInt a, myMathInt b) {
	return a * b;
}

// the function div already exists
myMathInt divv(myMathInt a, myMathInt b) {
	return a / b;
}

myMathInt bigSum(myMathInt a, myMathInt b, myMathInt c, myMathInt d, myMathInt e) {
	return a + b + c + d + e;
}

myMathInt bigMul(myMathInt a, myMathInt b, myMathInt c, myMathInt d, myMathInt e) {
	return a * b * c * d * e;
}

void main1(void) {
	struct {
		myMathInt history[10];
		char buffer[128];
		myMathInt (*operatorsBig[2])(myMathInt,myMathInt,myMathInt,myMathInt,myMathInt);
		myMathInt (*operators[4])(myMathInt, myMathInt);
	} s = {{0}, "", {bigSum, bigMul}, {mul, add, sub, divv}};
	myMathInt a, b, c, d, e;
	char op;

	s.buffer[127] = 0;
	while (1) {
		puts("Enter a simple math operation (a[+-*/]b, no spaces) or ? or @ to sum or multiply five numbers");
		fgets(s.buffer, 127, stdin);
		myMathInt res;
		if ('0' <= s.buffer[0] && s.buffer[0] <= '9') {
			sscanf_s(s.buffer, "%zd%c%zd", &a, &op, 1, &b);
			int actualOperation = (op-1)/2 - 20; // * + - / -> 0 1 2 3... but vulnerable
			res = (*s.operators[actualOperation])(a, b);
		} else {
			sscanf_s(s.buffer, "%c%zd%zd%zd%zd%zd", &op, 1, &a, &b, &c, &d, &e);
			int actualOperation = op - 63; // ? @ -> 0 1... but vulnerable
			res = (*s.operatorsBig[actualOperation])(a, b, c, d, e);
		}
		printf("The result is %zd\n", res);
		memmove(s.history + 1, s.history, 9 * sizeof(myMathInt));
		s.history[0] = res;
	}
}

int main(void) {
	char waste[1024] = "";
	waste[1023] = '\0';

	setvbuf(stdin, 0, _IONBF, 0);
	setvbuf(stdout, 0, _IONBF, 0);
	setvbuf(stderr, 0, _IONBF, 0);

	// leaking is not the point of this example, so free leak
	//printf("Base address is %p\n", GetModuleHandleA(0));
	printf("printFlag is at %p\n", printFlag);
	printf("VirtualAlloc is at %p\n", VirtualAlloc);

	main1();

	puts(waste+1023);
	// dummy dereferences to add stuff to cfg
	/*puts(stdcallToCdecl4);
	puts(__acrt_iob_func);*/
	//puts(fgets);
	uintptr_t pippo = (uintptr_t) fgets;
	pippo = (uintptr_t) stdcallToCdecl4;
	pippo = (uintptr_t) __acrt_iob_func;
	//printf("%lu\n", pippo);

	return 0;
}
